import { ref, reactive, getCurrentInstance } from 'vue';
import { handleGenerateClick as handleGenerateClickBase } from '@/views/_components/base/stream';
import { saveTool, deleteTool, fetchTools, getTool, importTool } from './components/TopMenu/components/ToolActions/toolActionsApi';
import generateUUID from '@/views/_utils/generateUUID.js';
import { toKebabCase } from '@/views/_utils/stringFormatting.js';
import { API_CONFIG } from '@/tt.config.js';

// Helper function to get default outputs based on tool type
function getDefaultOutputs(toolType) {
  if (toolType === 'AI') {
    return {
      generatedText: {
        type: 'string',
        description: 'The text generated by the LLM',
      },
      tokenCount: {
        type: 'integer',
        description: 'The number of tokens in the generated text',
      },
      error: {
        type: 'string',
        description: 'Error message if the LLM call failed',
      },
    };
  } else {
    // CODE_JS or CODE_PYTHON
    return {
      success: {
        type: 'boolean',
        description: 'Indicates whether the operation was successful',
      },
      result: {
        type: 'any',
        description: 'The result data from the tool execution',
      },
      error: {
        type: 'string',
        description: 'Error message if the operation failed',
      },
    };
  }
}

const initialFormState = {
  title: '',
  instructions: '',
  icon: 'custom',
  provider: '',
  model: '',
  customFields: {},
  customOutputs: getDefaultOutputs('AI'), // Default to AI outputs
  toolType: 'AI',
  code: '',
};

export function useToolPanel() {
  const selectedTool = ref(null);
  const formData = reactive({ ...initialFormState });
  const templates = ref([]);
  const { proxy } = getCurrentInstance();

  async function fetchTemplates() {
    try {
      const fetchedTemplates = await fetchTools();
      templates.value = fetchedTemplates;
    } catch (error) {
      console.error('Error fetching templates:', error);
    }
  }
  async function handleGenerateClick(event) {
    try {
      await handleGenerateClickBase(event);
    } catch (error) {
      console.error('Generation cancelled or failed:', error);
      // You can add additional error handling here if needed
    }
  }
  function onFormUpdated(key, value) {
    console.log('onFormUpdated called:', key, value, 'current:', formData[key]);

    if (key === 'customFields') {
      formData.customFields = value;
    } else if (key === 'customOutputs') {
      formData.customOutputs = value;
    } else if (key === 'toolType') {
      // ALWAYS update when toolType changes, even if same value
      console.log('Tool type changing to:', value);
      formData[key] = value;
      // Force reactive update by creating new object
      const newOutputs = getDefaultOutputs(value);
      console.log('New outputs for', value, ':', newOutputs);
      formData.customOutputs = { ...newOutputs };
      console.log('customOutputs updated to:', formData.customOutputs);
    } else if (formData[key] !== value) {
      formData[key] = value;
    }
  }
  function onToolSelected(tool) {
    if (tool && tool.id) {
      selectedTool.value = tool;
      Object.assign(formData, initialFormState);
      formData.id = tool.id;
      formData.title = tool.title || '';
      formData.toolType = tool.base || 'AI';
      formData.code = tool.code || '';
      formData.instructions = tool.parameters?.instructions || '';
      formData.provider = tool.parameters?.provider || '';
      formData.model = tool.parameters?.model || '';
      formData.icon = tool.icon || 'custom';
      formData.isShareable = tool.isShareable || false;
      formData.customFields = {};

      // Initialize with default outputs based on tool type
      formData.customOutputs = getDefaultOutputs(formData.toolType);

      if (tool.parameters) {
        for (const [key, value] of Object.entries(tool.parameters)) {
          if (!['instructions', 'provider', 'model'].includes(key)) {
            formData.customFields[key] = value;
          }
        }
      }

      // Use saved outputs if they exist, otherwise keep defaults
      if (tool.outputs && Object.keys(tool.outputs).length > 0) {
        formData.customOutputs = { ...tool.outputs };
      }
    } else if (tool && tool.toolId) {
      // This handles the case where onToolSelected is called after saving a tool
      getTool(tool.toolId)
        .then((fetchedTool) => {
          onToolSelected(fetchedTool);
        })
        .catch((error) => {
          console.error('Error fetching saved tool:', error);
        });
    } else if (tool === 'create-new') {
      clearFields();
    } else {
      if (!formData.id) {
        clearFields();
      }
    }
  }
  function onToolGenerated(generatedTool) {
    function toTitleCase(str) {
      return str
        .split('-')
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
    }

    const tool = {
      id: generateUUID(),
      title: generatedTool.name || '',
      icon: 'custom',
      parameters: {
        instructions: generatedTool.fields.find((f) => f.name === 'template-instructions')?.value || '',
        provider: '', // You may want to set a default provider
        model: '', // You may want to set a default model
      },
    };

    // Map other fields to parameters with transformed names and values
    generatedTool.fields.forEach((field) => {
      if (!['template-name', 'template-instructions'].includes(field.name)) {
        const transformedName = toTitleCase(field.name);
        tool.parameters[transformedName] = {
          type: field.type,
          value: field.value,
          label: transformedName,
        };
      }
    });

    onToolSelected(tool);
  }
  async function onToolSaved(savedTool) {
    selectedTool.value = savedTool;
  }
  function onToolDeleted() {
    selectedTool.value = null;
    clearFields();
  }
  async function clearFields() {
    const confirmed = await proxy.showConfirm('Clear Fields', 'Are you sure you want to clear the fields?', {
      confirmText: 'Clear',
      cancelText: 'Cancel',
      confirmClass: 'btn-danger',
      cancelClass: 'btn-secondary',
    });
    if (confirmed) {
      Object.assign(formData, initialFormState);
      formData.customFields = {};
      formData.customOutputs = getDefaultOutputs(formData.toolType);
      selectedTool.value = null;
    }
  }
  async function saveFormDataToDB(isSharing = false) {
    try {
      const currentUserId = localStorage.getItem('userId');
      const isCodeTool = formData.toolType === 'CODE_JS' || formData.toolType === 'CODE_PYTHON';

      const toolData = {
        id: formData.id,
        base: formData.toolType || 'AI',
        title: formData.title || 'My Custom Tool',
        category: formData.category || 'custom',
        type: toKebabCase(formData.title) || 'custom',
        icon: formData.icon,
        description: 'This is a custom tool built by a user in the Tool Forge.',
        code: isCodeTool ? formData.code : null,
        parameters:
          formData.toolType === 'AI'
            ? {
                instructions: formData.instructions,
                provider: formData.provider,
                model: formData.model,
                ...formData.customFields,
              }
            : isCodeTool
            ? formData.customFields
            : {
                instructions: formData.instructions,
                provider: formData.provider,
                model: formData.model,
                ...formData.customFields,
              },
        outputs:
          formData.toolType === 'AI' && formData.customOutputs && Object.keys(formData.customOutputs).length > 0
            ? formData.customOutputs
            : isCodeTool && formData.customOutputs && Object.keys(formData.customOutputs).length > 0
            ? formData.customOutputs
            : formData.toolType === 'AI'
            ? {
                generatedText: {
                  type: 'string',
                  description: 'The text generated by the LLM',
                },
                tokenCount: {
                  type: 'integer',
                  description: 'The number of tokens in the generated text',
                },
                error: {
                  type: 'string',
                  description: 'Error message if the LLM call failed',
                },
              }
            : {
                success: {
                  type: 'boolean',
                  description: 'Indicates whether the operation was successful',
                },
                result: {
                  type: 'any',
                  description: isCodeTool ? 'The result from code execution' : 'The text generated by the LLM',
                },
                error: {
                  type: 'string',
                  description: 'Error message if the operation failed',
                },
              },
        createdBy: currentUserId,
        isShareable: formData.isShareable,
      };

      // Always save to the base URL first
      const savedTool = await saveTool(toolData, API_CONFIG.BASE_URL);

      if (savedTool && savedTool.id) {
        formData.id = savedTool.id;
        toolData.id = savedTool.id; // Ensure the ID is set for remote saving

        // Show alert for saving to local database
        proxy.showAlert('Tool saved to database successfully!');

        // If sharing, update isShareable and save to the remote URL
        if (isSharing === true) {
          toolData.isShareable = true;
          formData.isShareable = true;
          await saveTool(toolData, API_CONFIG.REMOTE_URL);
          proxy.showAlert('Tool shared to remote database successfully!');
        }

        return { id: savedTool.id, isShareable: formData.isShareable };
      } else {
        throw new Error('Invalid response from server');
      }
    } catch (error) {
      console.error('Error saving/updating tool:', error);
      proxy.showAlert('Failed to save/update tool. Please try again.');
      throw error;
    }
  }
  async function confirmDelete() {
    if (
      await proxy.showConfirm('Delete Tool', 'Are you sure you want to delete this tool?', {
        confirmText: 'Delete',
        cancelText: 'Cancel',
        confirmClass: 'btn-danger',
        cancelClass: 'btn-secondary',
      })
    ) {
      if (selectedTool.value) {
        try {
          await deleteTool(selectedTool.value.id);
          onToolDeleted();
          await fetchTemplates();
          proxy.showAlert('Tool deleted successfully!');
        } catch (error) {
          console.error('Error deleting tool:', error);
        }
      }
    }
  }
  async function importTemplate() {
    const toolId = await proxy.showPrompt('Import Tool', 'Please enter the tool ID you want to import:', '', {
      isTextArea: false,
      placeholder: 'Enter tool ID',
      defaultValue: '',
      confirmText: 'Import',
      cancelText: 'Cancel',
    });
    if (toolId) {
      try {
        const importedTool = await importTool(toolId);
        if (importedTool) {
          onToolSelected(importedTool);
          proxy.showAlert('Tool imported successfully!');
        } else {
          proxy.showAlert('No tool found with the given ID.');
        }
      } catch (error) {
        console.error('Error importing tool:', error);
        if (error.message.includes('403')) {
          proxy.showAlert("You don't have permission to access this tool. It might not be shared.");
        } else {
          proxy.showAlert('Failed to import tool. Please check the ID and try again.');
        }
      }
    }
  }
  async function shareTemplate() {
    if (formData.id) {
      try {
        const result = await saveFormDataToDB(true);
        if (result && result.id) {
          await navigator.clipboard.writeText(result.id);
          proxy.showAlert(`Tool is now shareable. The ID has been copied to your clipboard: ${result.id}`);
        }
      } catch (err) {
        console.error('Failed to share tool: ', err);
        proxy.showAlert('Failed to share tool. Please try again.');
      }
    } else {
      proxy.showAlert('No tool is selected or the tool does not exist.');
    }
  }
  async function loadToolById(toolId) {
    try {
      const tool = await getTool(toolId);
      if (tool) {
        onToolSelected(tool);
      } else {
        console.error('Tool not found');
        // You might want to show an error message to the user here
      }
    } catch (error) {
      console.error('Error loading tool by ID:', error);
      // You might want to show an error message to the user here
    }
  }

  return {
    selectedTool,
    formData,
    templates,
    handleGenerateClick,
    onFormUpdated,
    onToolSelected,
    onToolSaved,
    onToolDeleted,
    clearFields,
    saveFormDataToDB,
    confirmDelete,
    importTemplate,
    shareTemplate,
    onToolGenerated,
    fetchTemplates,
    loadToolById,
  };
}
