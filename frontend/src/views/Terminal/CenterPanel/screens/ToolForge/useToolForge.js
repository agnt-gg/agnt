import { ref } from 'vue';
import {
  saveTool,
  fetchTools,
  getTool,
  deleteTool,
} from '@/views/Terminal/RightPanel/types/ToolForgePanel/components/ToolPanel/components/TopMenu/components/ToolActions/toolActionsApi.js';
import generateUUID from '@/views/_utils/generateUUID.js';
import { toKebabCase } from '@/views/_utils/stringFormatting.js';
import { handleGenerateClick } from '@/views/_components/base/stream';
import { API_CONFIG, AI_PROVIDERS_CONFIG } from '../../../../../../user.config.js';
import store from '@/store/state';

export default function useToolForge() {
  const toolOutput = ref('');
  const isExecuting = ref(false);

  // Tutorial configuration
  const tutorialConfig = [
    // {
    //   target: '.tool-metadata',
    //   content: 'This area shows information about your currently selected tool.',
    //   placement: 'bottom',
    // },
    // {
    //   target: '.response-area-container',
    //   content: 'Tool output will be displayed here when you run your tool.',
    //   placement: 'top',
    // },
    // {
    //   target: '.action-btn.test-btn',
    //   content: 'Click here to test your tool once it\'s configured.',
    //   placement: 'left',
    // }
  ];

  const startTutorial = ref(false);

  const onTutorialClose = () => {
    console.log('Tutorial closed');
    startTutorial.value = false;
  };

  const initializeToolForge = async () => {
    try {
      // Simple initialization without relying on Vuex
      startTutorial.value = true;
      return true;
    } catch (error) {
      console.error('Failed to initialize Tool Forge:', error);
      return false;
    }
  };

  // Map the new tool format to the existing custom tool format
  const mapToolForgeToCustomTool = (toolForgeData) => {
    const customFields = {};

    if (toolForgeData.fields) {
      toolForgeData.fields.forEach((field) => {
        customFields[field.name] = {
          type: field.type,
          value: field.defaultValue || '',
          label: field.description || field.name,
        };
      });
    }

    const base = toolForgeData.toolType || 'AI';
    const isCodeTool = base === 'CODE_JS' || base === 'CODE_PYTHON';

    return {
      id: toolForgeData.id || generateUUID(),
      base: base,
      title: toolForgeData.name || 'Untitled Tool',
      category: 'custom',
      type: toKebabCase(toolForgeData.name) || 'custom-tool',
      icon: 'custom',
      description: toolForgeData.description || 'No description provided',
      code: isCodeTool ? toolForgeData.code : null,
      config: toolForgeData.config || null,
      parameters: isCodeTool
        ? customFields
        : {
            instructions: toolForgeData.promptTemplate || '',
            provider: toolForgeData.provider || AI_PROVIDERS_CONFIG.providers[0] || '',
            model: toolForgeData.model || AI_PROVIDERS_CONFIG.modelsByProvider[toolForgeData.provider || AI_PROVIDERS_CONFIG.providers[0]]?.[0] || '',
            ...customFields,
          },
      outputs:
        isCodeTool && toolForgeData.customOutputs && Object.keys(toolForgeData.customOutputs).length > 0
          ? toolForgeData.customOutputs
          : {
              success: {
                type: 'boolean',
                description: 'Indicates whether the operation was successful',
              },
              result: {
                type: 'any',
                description: isCodeTool ? 'The result from code execution' : 'The text generated by the LLM',
              },
              error: {
                type: 'string',
                description: 'Error message if the operation failed',
              },
            },
      isValid: toolForgeData.isValid || false,
      isSaved: toolForgeData.isSaved || false,
    };
  };

  // Map the existing custom tool format to the new tool forge format
  const mapCustomToolToToolForge = (customTool) => {
    const fields = [];

    const defaultProvider = AI_PROVIDERS_CONFIG.providers[0] || '';
    const defaultModel = defaultProvider ? AI_PROVIDERS_CONFIG.modelsByProvider[defaultProvider]?.[0] || '' : '';

    const base = customTool.base || 'AI';
    const isCodeTool = base === 'CODE_JS' || base === 'CODE_PYTHON';

    if (customTool.parameters) {
      for (const [key, value] of Object.entries(customTool.parameters)) {
        if (!['instructions', 'provider', 'model'].includes(key)) {
          fields.push({
            id: `field-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
            name: key,
            type: value.type || 'text',
            description: value.label || key,
            required: true,
            defaultValue: value.value || '',
            options: '',
          });
        }
      }
    }

    return {
      id: customTool.id,
      toolType: base,
      name: customTool.title || 'Untitled Tool',
      description: customTool.description || '',
      code: customTool.code || '',
      config: customTool.config || null,
      customOutputs: customTool.outputs || {},
      promptTemplate: !isCodeTool ? customTool.parameters?.instructions || '' : '',
      provider: !isCodeTool ? customTool.parameters?.provider || defaultProvider : defaultProvider,
      model: !isCodeTool ? customTool.parameters?.model || defaultModel : defaultModel,
      fields: fields,
      isValid: true,
      isSaved: true,
    };
  };

  // Save a tool
  const saveToolTemplate = async (toolData) => {
    try {
      const mappedTool = mapToolForgeToCustomTool(toolData);
      const result = await saveTool(mappedTool);

      if (result && result.toolId) {
        return {
          ...toolData,
          id: result.toolId,
          isSaved: true,
        };
      } else {
        throw new Error('Failed to save tool');
      }
    } catch (error) {
      console.error('Error saving tool:', error);
      throw error;
    }
  };

  // Load all tools
  const loadTools = async () => {
    try {
      const tools = await fetchTools();
      return tools.map((tool) => mapCustomToolToToolForge(tool));
    } catch (error) {
      console.error('Error loading tools:', error);
      return [];
    }
  };

  // Load a specific tool
  const loadTool = async (toolId) => {
    try {
      const tool = await getTool(toolId);
      if (tool) {
        return mapCustomToolToToolForge(tool);
      }
      return null;
    } catch (error) {
      console.error('Error loading tool:', error);
      return null;
    }
  };

  // Delete a tool
  const deleteToolTemplate = async (toolId) => {
    try {
      await deleteTool(toolId);
      return true;
    } catch (error) {
      console.error('Error deleting tool:', error);
      return false;
    }
  };

  // Execute a tool using the streaming API
  const executeToolTemplate = async (toolData) => {
    isExecuting.value = true;
    toolOutput.value = '';

    const defaultProvider = AI_PROVIDERS_CONFIG.providers[0] || 'openai'; // Fallback to openai if no config
    const defaultModel = defaultProvider ? AI_PROVIDERS_CONFIG.modelsByProvider[defaultProvider]?.[0] || 'gpt-4o-mini' : 'gpt-4o-mini';

    try {
      // Create a form element to hold our tool data
      const formElement = document.createElement('form');
      formElement.id = 'template-form';

      // Prepare the template data - the user's current message is crucial for the streaming API
      const userMessage = document.createElement('input');
      userMessage.type = 'hidden';
      userMessage.name = 'user-current-message';
      userMessage.value = toolData.promptTemplate || '';

      // Add instructions
      const instructions = document.createElement('input');
      instructions.type = 'hidden';
      instructions.name = 'instructions';
      instructions.value = toolData.promptTemplate || '';
      formElement.appendChild(instructions);

      // Add provider
      const provider = document.createElement('input');
      provider.type = 'hidden';
      provider.name = 'provider';
      provider.value = toolData.provider || defaultProvider;
      formElement.appendChild(provider);

      // Add model
      const model = document.createElement('input');
      model.type = 'hidden';
      model.name = 'model';
      model.value = toolData.model || defaultModel;
      formElement.appendChild(model);

      // Add all field values as inputs
      if (toolData.fields && toolData.fields.length > 0) {
        toolData.fields.forEach((field) => {
          if (field.name) {
            const fieldInput = document.createElement('input');
            fieldInput.type = 'hidden';
            fieldInput.name = field.name;
            fieldInput.value = field.defaultValue || '';
            formElement.appendChild(fieldInput);
          }
        });
      }

      // Make sure all required elements exist in the DOM
      const responseDiv = document.getElementById('response-area');
      const generateButton = document.querySelector('.generate');
      const contentActions = document.getElementById('content-actions');

      if (!responseDiv || !generateButton || !contentActions) {
        console.error('Required DOM elements not found for streaming');
        throw new Error('Required DOM elements not found. Please refresh the page and try again.');
      }

      // Clear any existing placeholder
      const placeholder = document.getElementById('placeholder-text');
      if (placeholder) {
        placeholder.remove();
      }

      // Set up store state for streaming
      store.commit('chat/SET_PAGE', 'toolforge');
      store.commit('chat/SET_STREAMING', false);
      store.commit('chat/SET_ACTIVE_STREAM', null);

      // Temporarily add the form to the document
      document.body.appendChild(formElement);

      // Create a fake event to pass to handleGenerateClick
      const fakeEvent = {
        preventDefault: () => {},
        stopPropagation: () => {},
      };

      // Create a MutationObserver to watch for changes to the response div
      const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type === 'childList' || mutation.type === 'characterData') {
            // Check if there's an assistant message to extract content from
            const assistantMessage = responseDiv.querySelector('.assistant-message-receive');
            if (assistantMessage) {
              // Update our toolOutput with the latest content
              toolOutput.value = assistantMessage.textContent || '';
            } else {
              // If no assistant message yet, just use the entire response area content
              toolOutput.value = responseDiv.textContent || '';
            }
          }
        }
      });

      // Start observing
      observer.observe(responseDiv, {
        childList: true,
        characterData: true,
        subtree: true,
      });

      try {
        // Start the generate process
        await handleGenerateClick(fakeEvent);
      } catch (error) {
        console.error('Error during stream generation:', error);
        observer.disconnect();
        throw error;
      }

      // Stop observing once generation is complete
      observer.disconnect();

      // Clean up
      document.body.removeChild(formElement);

      // Get the final result
      const assistantMessage = responseDiv.querySelector('.assistant-message-receive');
      const finalOutput = assistantMessage ? assistantMessage.textContent : responseDiv.textContent || 'No output received from tool execution';
      toolOutput.value = finalOutput;

      isExecuting.value = false;
      return { output: finalOutput };
    } catch (error) {
      console.error('Error executing tool:', error);
      isExecuting.value = false;
      toolOutput.value = `Error: ${error.message || 'Unknown error during tool execution'}`;
      throw error;
    }
  };

  return {
    tutorialConfig,
    startTutorial,
    onTutorialClose,
    initializeToolForge,
    saveToolTemplate,
    loadTools,
    loadTool,
    deleteToolTemplate,
    executeToolTemplate,
    mapToolForgeToCustomTool,
    mapCustomToolToToolForge,
  };
}
