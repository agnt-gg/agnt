<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ü§ñ AI Alpha Trader ‚Äî Beat the Market with AI</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
:root{--bg:#0a0e17;--card:#111827;--border:#1f2937;--text:#e5e7eb;--muted:#9ca3af;--accent:#3b82f6;--green:#10b981;--red:#ef4444;--gold:#f59e0b;--purple:#8b5cf6;--cyan:#06b6d4;--warn:#dc2626;--ai-glow:rgba(139,92,246,.3)}
*{margin:0;padding:0;box-sizing:border-box}
body{background:var(--bg);color:var(--text);font-family:'Inter',-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;font-size:14px;min-height:100vh}

/* Header */
.header{background:linear-gradient(135deg,#1e1b4b,#0f172a);padding:20px 28px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:12px}
.header-left h1{font-size:24px;font-weight:800;background:linear-gradient(90deg,#60a5fa,#a78bfa,#34d399);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.header-left p{color:var(--muted);margin-top:4px;font-size:12px}
.header-right{display:flex;gap:12px;align-items:center}
.api-input{background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:8px 14px;color:var(--text);font-size:12px;width:300px;font-family:monospace}
.api-input:focus{outline:none;border-color:var(--accent)}
.btn{padding:8px 18px;border-radius:8px;cursor:pointer;font-size:12px;font-weight:700;border:none;transition:all .2s;text-transform:uppercase;letter-spacing:.5px}
.btn-primary{background:linear-gradient(135deg,#3b82f6,#8b5cf6);color:white}
.btn-primary:hover{transform:translateY(-1px);box-shadow:0 4px 20px rgba(59,130,246,.4)}
.btn-success{background:linear-gradient(135deg,#10b981,#059669);color:white}
.btn-danger{background:linear-gradient(135deg,#ef4444,#dc2626);color:white}
.btn-warn{background:linear-gradient(135deg,#f59e0b,#d97706);color:white}
.btn-ghost{background:rgba(255,255,255,.05);color:var(--muted);border:1px solid var(--border)}
.btn-ghost:hover{color:var(--text);border-color:var(--accent)}
.btn:disabled{opacity:.4;cursor:not-allowed;transform:none!important}
.btn-sm{padding:5px 12px;font-size:10px}

/* Layout */
.main{display:grid;grid-template-columns:320px 1fr 340px;gap:0;height:calc(100vh - 72px)}
@media(max-width:1200px){.main{grid-template-columns:1fr;height:auto}}

/* Left Panel - Market Data */
.panel-left{border-right:1px solid var(--border);overflow-y:auto;background:rgba(17,24,39,.6)}
.panel-center{overflow-y:auto}
.panel-right{border-left:1px solid var(--border);overflow-y:auto;background:rgba(17,24,39,.6)}

.panel-header{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center}
.panel-header h2{font-size:13px;font-weight:700;text-transform:uppercase;letter-spacing:.8px;display:flex;align-items:center;gap:6px}
.panel-body{padding:12px}

/* Market Ticker */
.ticker-strip{display:flex;gap:0;overflow-x:auto;border-bottom:1px solid var(--border);background:rgba(0,0,0,.3)}
.ticker-item{padding:8px 14px;font-size:11px;white-space:nowrap;border-right:1px solid var(--border);display:flex;gap:8px;align-items:center;min-width:fit-content}
.ticker-item .sym{font-weight:700;color:var(--text)}
.ticker-item .price{font-weight:600}
.ticker-item .chg{font-weight:700;font-size:10px}

/* Stock Cards */
.stock-card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:12px;margin-bottom:8px;cursor:pointer;transition:all .2s}
.stock-card:hover{border-color:var(--accent);transform:translateX(2px)}
.stock-card.selected{border-color:var(--accent);background:rgba(59,130,246,.05);box-shadow:0 0 20px rgba(59,130,246,.1)}
.stock-row{display:flex;justify-content:space-between;align-items:center}
.stock-sym{font-weight:800;font-size:15px}
.stock-name{font-size:10px;color:var(--muted);margin-top:1px}
.stock-price{font-weight:700;font-size:15px;text-align:right}
.stock-chg{font-size:11px;font-weight:700;text-align:right}
.stock-mini-chart{height:30px;margin-top:6px;opacity:.6}

/* Portfolio Cards */
.stat-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:12px}
.stat-card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:12px;text-align:center}
.stat-card h4{font-size:9px;color:var(--muted);text-transform:uppercase;letter-spacing:.5px;margin-bottom:4px}
.stat-card .val{font-size:22px;font-weight:800}
.stat-card .sub{font-size:10px;color:var(--muted);margin-top:2px}
.stat-card.highlight{border-color:rgba(59,130,246,.3);background:rgba(59,130,246,.05)}

/* Holdings Table */
.holdings-table{width:100%;font-size:11px;border-collapse:collapse}
.holdings-table th{text-align:left;padding:6px 8px;color:var(--muted);font-weight:600;text-transform:uppercase;font-size:9px;letter-spacing:.5px;border-bottom:1px solid var(--border)}
.holdings-table td{padding:6px 8px;border-bottom:1px solid rgba(31,41,55,.5)}
.holdings-table tr:hover td{background:rgba(59,130,246,.03)}

/* Chart Area */
.chart-container{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:16px;margin:12px}
.chart-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:8px}
.chart-title{font-size:14px;font-weight:700}
.chart-controls{display:flex;gap:4px}
.time-btn{padding:4px 10px;border-radius:6px;font-size:10px;font-weight:600;color:var(--muted);background:transparent;border:1px solid transparent;cursor:pointer;transition:all .2s}
.time-btn:hover{color:var(--text)}
.time-btn.active{color:#60a5fa;background:rgba(59,130,246,.15);border-color:rgba(59,130,246,.3)}
.chart-wrap{position:relative;height:300px}

/* AI Chat Panel */
.ai-chat{display:flex;flex-direction:column;height:100%}
.ai-messages{flex:1;overflow-y:auto;padding:12px;display:flex;flex-direction:column;gap:8px}
.ai-msg{padding:10px 14px;border-radius:10px;font-size:12px;line-height:1.5;max-width:95%;animation:fadeIn .3s ease}
.ai-msg.system{background:rgba(59,130,246,.1);border:1px solid rgba(59,130,246,.2);color:#93c5fd;align-self:flex-start}
.ai-msg.user{background:rgba(139,92,246,.15);border:1px solid rgba(139,92,246,.2);color:#c4b5fd;align-self:flex-end}
.ai-msg.assistant{background:rgba(16,185,129,.08);border:1px solid rgba(16,185,129,.2);color:#6ee7b7;align-self:flex-start}
.ai-msg.tool{background:rgba(245,158,11,.08);border:1px solid rgba(245,158,11,.2);color:#fcd34d;align-self:flex-start;font-family:monospace;font-size:11px}
.ai-msg.error{background:rgba(239,68,68,.1);border:1px solid rgba(239,68,68,.2);color:#fca5a5;align-self:flex-start}
.ai-msg .msg-label{font-size:9px;font-weight:700;text-transform:uppercase;letter-spacing:.5px;margin-bottom:4px;opacity:.7}
.ai-msg pre{background:rgba(0,0,0,.3);padding:6px 8px;border-radius:6px;margin-top:6px;font-size:10px;overflow-x:auto;white-space:pre-wrap}
.ai-input-row{display:flex;gap:6px;padding:10px 12px;border-top:1px solid var(--border);background:rgba(0,0,0,.2)}
.ai-input{flex:1;background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:8px 12px;color:var(--text);font-size:12px;resize:none;font-family:inherit}
.ai-input:focus{outline:none;border-color:var(--purple)}

/* Trade Action Bar */
.trade-bar{display:flex;gap:6px;padding:10px 12px;border-top:1px solid var(--border);flex-wrap:wrap}
.trade-bar .btn{flex:1;min-width:60px;font-size:10px;padding:6px 8px}

/* Performance Strip */
.perf-strip{display:flex;gap:0;background:rgba(0,0,0,.3);border-bottom:1px solid var(--border)}
.perf-item{flex:1;padding:8px 12px;text-align:center;border-right:1px solid var(--border)}
.perf-item:last-child{border:none}
.perf-item .label{font-size:9px;color:var(--muted);text-transform:uppercase;letter-spacing:.3px}
.perf-item .value{font-size:16px;font-weight:800;margin-top:2px}

/* Game Status Bar */
.game-bar{background:linear-gradient(90deg,rgba(16,185,129,.08),rgba(59,130,246,.08));border-bottom:1px solid var(--border);padding:8px 28px;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px}
.game-bar .game-info{display:flex;gap:20px;font-size:12px}
.game-bar .game-info span{color:var(--muted)}
.game-bar .game-info strong{color:var(--text);margin-left:4px}
.game-controls{display:flex;gap:8px;align-items:center}

/* Allocation Bar */
.alloc-bar{display:flex;height:26px;border-radius:8px;overflow:hidden;margin:8px 0}
.alloc-seg{display:flex;align-items:center;justify-content:center;font-size:9px;font-weight:700;color:white;transition:all .3s}

/* AI Thinking Animation */
.thinking{display:flex;gap:4px;padding:12px}
.thinking-dot{width:6px;height:6px;border-radius:50%;background:var(--purple);animation:bounce .6s infinite alternate}
.thinking-dot:nth-child(2){animation-delay:.2s}
.thinking-dot:nth-child(3){animation-delay:.4s}
@keyframes bounce{to{opacity:.3;transform:translateY(-4px)}}
@keyframes fadeIn{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:translateY(0)}}

/* Pulse animation for live data */
.live-dot{width:6px;height:6px;border-radius:50%;background:var(--green);display:inline-block;animation:pulse 2s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.3}}

/* Scrollbar */
::-webkit-scrollbar{width:6px}
::-webkit-scrollbar-track{background:transparent}
::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
::-webkit-scrollbar-thumb:hover{background:var(--muted)}

/* Toast */
.toast{position:fixed;bottom:20px;right:20px;background:#1e40af;color:white;padding:10px 18px;border-radius:8px;font-size:12px;font-weight:600;transform:translateY(80px);opacity:0;transition:all .3s;z-index:999}
.toast.show{transform:translateY(0);opacity:1}
.toast.success{background:#059669}
.toast.error{background:#dc2626}
.toast.warn{background:#d97706}

/* Setup Modal */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);backdrop-filter:blur(8px);display:flex;align-items:center;justify-content:center;z-index:1000}
.modal{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:32px;max-width:520px;width:90%;max-height:90vh;overflow-y:auto}
.modal h2{font-size:22px;font-weight:800;margin-bottom:4px;background:linear-gradient(90deg,#60a5fa,#a78bfa);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.modal p{color:var(--muted);font-size:12px;margin-bottom:20px}
.modal label{display:block;font-size:11px;font-weight:600;color:var(--muted);margin-bottom:4px;text-transform:uppercase;letter-spacing:.5px}
.modal input,.modal select{width:100%;background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:10px 14px;color:var(--text);font-size:13px;margin-bottom:14px}
.modal input:focus,.modal select:focus{outline:none;border-color:var(--accent)}
.modal .hint{font-size:10px;color:var(--muted);margin-top:-10px;margin-bottom:14px}

/* Benchmark comparison */
.benchmark-row{display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid rgba(31,41,55,.5)}
.benchmark-row:last-child{border:none}
.bench-label{font-size:11px;color:var(--muted)}
.bench-val{font-size:12px;font-weight:700}

/* Trade History */
.trade-item{padding:8px 12px;border-bottom:1px solid rgba(31,41,55,.5);font-size:11px;display:flex;justify-content:space-between;align-items:center}
.trade-item .trade-type{font-weight:700;font-size:10px;padding:2px 8px;border-radius:4px}
.trade-item .trade-type.buy{background:rgba(16,185,129,.15);color:var(--green)}
.trade-item .trade-type.sell{background:rgba(239,68,68,.15);color:var(--red)}
.trade-item .trade-type.rebalance{background:rgba(245,158,11,.15);color:var(--gold)}

/* Score Board */
.score-card{background:linear-gradient(135deg,rgba(139,92,246,.1),rgba(59,130,246,.1));border:1px solid rgba(139,92,246,.3);border-radius:12px;padding:16px;text-align:center;margin-bottom:12px}
.score-card .score-val{font-size:42px;font-weight:900;background:linear-gradient(90deg,#60a5fa,#a78bfa,#34d399);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.score-card .score-label{font-size:10px;color:var(--muted);text-transform:uppercase;letter-spacing:1px;margin-top:4px}

/* AI Strategy Presets */
.preset-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:12px}
.preset-card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:10px;cursor:pointer;transition:all .2s;text-align:center}
.preset-card:hover{border-color:var(--purple);transform:translateY(-1px)}
.preset-card.active{border-color:var(--purple);background:rgba(139,92,246,.08)}
.preset-card .emoji{font-size:20px;margin-bottom:4px}
.preset-card .name{font-size:11px;font-weight:700}
.preset-card .desc{font-size:9px;color:var(--muted);margin-top:2px}
</style>
</head>
<body>

<!-- Setup Modal -->
<div class="modal-overlay" id="setupModal">
<div class="modal">
<h2>ü§ñ AI Alpha Trader</h2>
<p>Configure your AI trading agent to compete against the market. Use real-time data and OpenAI to make autonomous trading decisions.</p>

<label>OpenAI API Key</label>
<input type="password" id="apiKeyInput" placeholder="sk-..." />
<div class="hint">Your key stays in your browser ‚Äî never sent to any server except OpenAI.</div>

<label>Starting Capital ($)</label>
<input type="number" id="startCapital" value="100000" min="1000" step="1000" />

<label>AI Model</label>
<select id="modelSelect">
<option value="gpt-4o-mini">GPT-4o Mini (Fast & Cheap)</option>
<option value="gpt-4o">GPT-4o (Balanced)</option>
<option value="gpt-4.1">GPT-4.1 (Best Reasoning)</option>
</select>

<label>AI Personality / Strategy</label>
<div class="preset-grid">
<div class="preset-card active" data-strategy="balanced" onclick="selectStrategy(this)">
<div class="emoji">‚öñÔ∏è</div>
<div class="name">Balanced</div>
<div class="desc">Mix of growth & safety</div>
</div>
<div class="preset-card" data-strategy="aggressive" onclick="selectStrategy(this)">
<div class="emoji">üî•</div>
<div class="name">Aggressive</div>
<div class="desc">Max alpha, high risk</div>
</div>
<div class="preset-card" data-strategy="conservative" onclick="selectStrategy(this)">
<div class="emoji">üõ°Ô∏è</div>
<div class="name">Conservative</div>
<div class="desc">Capital preservation</div>
</div>
<div class="preset-card" data-strategy="momentum" onclick="selectStrategy(this)">
<div class="emoji">üöÄ</div>
<div class="name">Momentum</div>
<div class="desc">Trend following</div>
</div>
</div>

<label>Benchmark to Beat</label>
<select id="benchmarkSelect">
<option value="SPY">S&P 500 (SPY)</option>
<option value="QQQ">NASDAQ 100 (QQQ)</option>
<option value="DIA">Dow Jones (DIA)</option>
<option value="IWM">Russell 2000 (IWM)</option>
</select>

<label style="display:flex;align-items:center;gap:8px;margin-top:8px;cursor:pointer">
<input type="checkbox" id="useHistoricalData" style="width:auto;margin:0" />
<span style="font-size:12px;text-transform:none;letter-spacing:0">Use Historical Data (Backtest Mode)</span>
</label>
<div class="hint" style="margin-top:2px">Enable this to replay historical market data instead of random simulation. Useful for backtesting strategies.</div>

<button class="btn btn-primary" style="width:100%;padding:12px;font-size:14px;margin-top:12px" onclick="startGame()">
üöÄ Launch AI Trader
</button>
</div>
</div>

<!-- Main Game UI (hidden until start) -->
<div id="gameUI" style="display:none">

<!-- Header -->
<div class="header">
<div class="header-left">
<h1>ü§ñ AI Alpha Trader ‚Äî Live Battle vs. The Market</h1>
<p><span class="live-dot"></span> Real-time data ‚Ä¢ AI-powered trades ‚Ä¢ Beat the benchmark to win</p>
</div>
<div class="header-right">
<button class="btn btn-ghost btn-sm" onclick="showTradeHistory()">üìã Trades</button>
<button class="btn btn-ghost btn-sm" onclick="resetGame()">üîÑ Reset</button>
</div>
</div>

<!-- Performance Strip -->
<div class="perf-strip">
<div class="perf-item">
<div class="label">Portfolio Value</div>
<div class="value green" id="totalValue">$100,000</div>
</div>
<div class="perf-item">
<div class="label">P&L Today</div>
<div class="value" id="dailyPL">$0.00</div>
</div>
<div class="perf-item">
<div class="label">Total Return</div>
<div class="value" id="totalReturn">0.00%</div>
</div>
<div class="perf-item">
<div class="label">vs Benchmark</div>
<div class="value" id="vsBenchmark">+0.00%</div>
</div>
<div class="perf-item">
<div class="label">AI Score</div>
<div class="value purple" id="aiScore">0</div>
</div>
</div>

<!-- Game Status Bar -->
<div class="game-bar">
<div class="game-info">
<span>üïê Game Day: <strong id="gameDay">1</strong></span>
<span>üìä Strategy: <strong id="gameStrategy">Balanced</strong></span>
<span>üè¶ Cash: <strong id="gameCash">$100,000</strong></span>
<span>üìà Trades: <strong id="tradeCount">0</strong></span>
<span>üß† Model: <strong id="gameModel">gpt-4o-mini</strong></span>
</div>
<div class="game-controls">
<button class="btn btn-success btn-sm" id="btnNextDay" onclick="nextDay()">‚ñ∂Ô∏è Next Day</button>
<button class="btn btn-primary btn-sm" id="btnAutoPlay" onclick="toggleAutoPlay()">‚è© Auto-Play</button>
<button class="btn btn-warn btn-sm" onclick="letAIDecide()">ü§ñ AI Decide Now</button>
</div>
</div>

<!-- Main 3-Column Layout -->
<div class="main">

<!-- LEFT: Market Data -->
<div class="panel-left">
<div class="panel-header">
<h2>üìä Live Market</h2>
<span style="font-size:10px;color:var(--muted)" id="lastUpdate">--</span>
</div>
<div class="panel-body" id="stockList">
<!-- Stock cards rendered here -->
</div>
</div>

<!-- CENTER: Charts & Main View -->
<div class="panel-center">
<!-- Portfolio Performance Chart -->
<div class="chart-container">
<div class="chart-header">
<div class="chart-title">üìà Portfolio vs. Benchmark</div>
<div class="chart-controls">
<button class="time-btn active" data-range="1w">1W</button>
<button class="time-btn" data-range="1m">1M</button>
<button class="time-btn" data-range="3m">3M</button>
<button class="time-btn" data-range="all">ALL</button>
</div>
</div>
<div class="chart-wrap">
<canvas id="perfChart"></canvas>
</div>
</div>

<!-- Allocation Chart -->
<div class="chart-container">
<div class="chart-header">
<div class="chart-title">ü•ß Current Allocation</div>
</div>
<div class="alloc-bar" id="allocBar">
<div class="alloc-seg" style="width:100%;background:var(--muted)">100% CASH</div>
</div>
<div style="margin-top:12px">
<table class="holdings-table">
<thead>
<tr><th>Asset</th><th>Shares</th><th>Avg Cost</th><th>Current</th><th>P&L</th><th>Weight</th></tr>
</thead>
<tbody id="holdingsBody">
<tr><td colspan="6" style="text-align:center;color:var(--muted);padding:20px">No holdings yet ‚Äî let the AI trade!</td></tr>
</tbody>
</table>
</div>
</div>

<!-- Score Card -->
<div style="padding:0 12px 12px">
<div class="score-card">
<div class="score-val" id="bigScore">0</div>
<div class="score-label">Alpha Score ‚Äî Beat the Market to Win!</div>
</div>
<div class="stat-grid">
<div class="stat-card">
<h4>Sharpe Ratio</h4>
<div class="val" id="sharpeVal">0.00</div>
</div>
<div class="stat-card">
<h4>Max Drawdown</h4>
<div class="val red" id="maxDDVal">0.00%</div>
</div>
<div class="stat-card">
<h4>Win Rate</h4>
<div class="val" id="winRateVal">0%</div>
</div>
<div class="stat-card">
<h4>Benchmark Return</h4>
<div class="val" id="benchRetVal">0.00%</div>
</div>
</div>
</div>
</div>

<!-- RIGHT: AI Agent Chat -->
<div class="panel-right">
<div class="panel-header">
<h2>üß† AI Trading Agent</h2>
<span class="live-dot"></span>
</div>
<div class="ai-chat">
<div class="ai-messages" id="aiMessages">
<div class="ai-msg system">
<div class="msg-label">System</div>
Welcome to AI Alpha Trader! I'm your AI trading agent. I'll analyze market data and make trading decisions to beat the benchmark. Click <strong>"AI Decide Now"</strong> or advance the day to see me in action!
</div>
</div>
<div class="trade-bar">
<button class="btn btn-success btn-sm" onclick="manualAction('buy')">üü¢ Buy</button>
<button class="btn btn-danger btn-sm" onclick="manualAction('sell')">üî¥ Sell</button>
<button class="btn btn-warn btn-sm" onclick="manualAction('rebalance')">‚öñÔ∏è Rebalance</button>
<button class="btn btn-ghost btn-sm" onclick="manualAction('hedge')">üõ°Ô∏è Hedge</button>
</div>
<div class="ai-input-row">
<textarea class="ai-input" id="chatInput" rows="2" placeholder="Ask the AI anything about the market or strategy..." onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();sendChat()}"></textarea>
<button class="btn btn-primary" onclick="sendChat()">Send</button>
</div>
</div>
</div>

</div><!-- /main -->
</div><!-- /gameUI -->

<!-- Toast -->
<div class="toast" id="toast"></div>

<script>
// ===== GAME STATE =====
const STATE = {
  apiKey: '',
  model: 'gpt-4o-mini',
  strategy: 'balanced',
  benchmark: 'SPY',
  startCapital: 100000,
  cash: 100000,
  holdings: {},       // { AAPL: { shares: 10, avgCost: 150 }, ... }
  day: 0,
  history: [],        // [{day, portfolioValue, benchmarkValue}]
  trades: [],         // [{day, type, symbol, shares, price, total}]
  marketData: {},     // { AAPL: { price, change, changePct, name, history:[] } }
  messages: [],       // Chat history for AI context
  autoPlay: false,
  autoPlayInterval: null,
  peakValue: 100000,
  maxDrawdown: 0,
  dailyReturns: [],
  benchmarkStart: null,
  benchmarkHistory: [],
  score: 0,
  // Historical data support
  useHistoricalData: false,
  historicalData: {},  // { AAPL: [{date, open, high, low, close, volume}] }
  historicalDayIndex: 0,
  historicalStartDate: null,
  historicalEndDate: null
};

// Watchlist of popular tickers
const WATCHLIST = ['AAPL','MSFT','GOOGL','AMZN','NVDA','META','TSLA','SPY','QQQ','JPM','V','UNH','XOM','JNJ','WMT','DIA','IWM','GLD','TLT','BTC-USD'];

const STOCK_NAMES = {
  'AAPL':'Apple','MSFT':'Microsoft','GOOGL':'Alphabet','AMZN':'Amazon','NVDA':'NVIDIA',
  'META':'Meta','TSLA':'Tesla','SPY':'S&P 500 ETF','QQQ':'Nasdaq 100 ETF','JPM':'JPMorgan',
  'V':'Visa','UNH':'UnitedHealth','XOM':'ExxonMobil','JNJ':'Johnson & Johnson','WMT':'Walmart',
  'DIA':'Dow Jones ETF','IWM':'Russell 2000 ETF','GLD':'Gold ETF','TLT':'Bond ETF','BTC-USD':'Bitcoin'
};

const COLORS = ['#3b82f6','#8b5cf6','#10b981','#f59e0b','#ef4444','#06b6d4','#f472b6','#a78bfa','#fb923c','#64748b','#fbbf24','#34d399','#818cf8','#f87171','#22d3ee','#c084fc','#4ade80','#fbbf24','#94a3b8','#e879f9'];

// ===== CHARTS =====
let perfChart = null;

function initCharts() {
  const ctx = document.getElementById('perfChart').getContext('2d');
  perfChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [
        {
          label: 'Your Portfolio',
          data: [],
          borderColor: '#8b5cf6',
          backgroundColor: 'rgba(139,92,246,.1)',
          fill: true,
          tension: 0.3,
          borderWidth: 2,
          pointRadius: 0
        },
        {
          label: 'Benchmark (' + STATE.benchmark + ')',
          data: [],
          borderColor: '#3b82f6',
          backgroundColor: 'rgba(59,130,246,.05)',
          fill: true,
          tension: 0.3,
          borderWidth: 2,
          borderDash: [5,5],
          pointRadius: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: { intersect: false, mode: 'index' },
      plugins: {
        legend: { labels: { color: '#9ca3af', font: { size: 10 } } },
        tooltip: {
          backgroundColor: '#1f2937',
          titleColor: '#e5e7eb',
          bodyColor: '#e5e7eb',
          callbacks: {
            label: ctx => ctx.dataset.label + ': $' + ctx.parsed.y.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2})
          }
        }
      },
      scales: {
        x: { grid: { color: 'rgba(31,41,55,.5)' }, ticks: { color: '#6b7280', font: { size: 9 } } },
        y: { grid: { color: 'rgba(31,41,55,.5)' }, ticks: { color: '#6b7280', font: { size: 9 }, callback: v => '$' + (v/1000).toFixed(0) + 'k' } }
      }
    }
  });
}

// ===== MARKET DATA (Yahoo Finance via public proxy) =====
async function fetchMarketData() {
  const symbols = WATCHLIST;
  const results = {};

  // Use multiple data approaches for reliability
  try {
    // Approach: Use Yahoo Finance v8 API (public, no key needed)
    const promises = symbols.map(async (sym) => {
      try {
        const url = `https://query1.finance.yahoo.com/v8/finance/chart/${sym}?range=1mo&interval=1d`;
        const resp = await fetch(url);
        if (!resp.ok) throw new Error('Yahoo API failed');
        const data = await resp.json();
        const result = data.chart.result[0];
        const meta = result.meta;
        const quotes = result.indicators.quote[0];
        const closes = quotes.close.filter(v => v !== null);
        const prevClose = meta.chartPreviousClose || closes[closes.length - 2] || meta.regularMarketPrice;
        const currentPrice = meta.regularMarketPrice;
        const change = currentPrice - prevClose;
        const changePct = (change / prevClose) * 100;

        results[sym] = {
          price: currentPrice,
          change: change,
          changePct: changePct,
          name: STOCK_NAMES[sym] || sym,
          history: closes,
          high: meta.regularMarketDayHigh || currentPrice,
          low: meta.regularMarketDayLow || currentPrice,
          volume: meta.regularMarketVolume || 0
        };
      } catch (e) {
        // Fallback: generate simulated data based on realistic values
        const basePrice = getBasePrice(sym);
        const vol = getVolatility(sym);
        const history = generateHistory(basePrice, vol, 22);
        const price = history[history.length - 1];
        const prev = history[history.length - 2];
        results[sym] = {
          price: price,
          change: price - prev,
          changePct: ((price - prev) / prev) * 100,
          name: STOCK_NAMES[sym] || sym,
          history: history,
          high: price * 1.005,
          low: price * 0.995,
          volume: Math.floor(Math.random() * 50000000) + 1000000
        };
      }
    });

    await Promise.allSettled(promises);
  } catch (e) {
    console.error('Market data fetch error:', e);
    // Full fallback
    symbols.forEach(sym => {
      const basePrice = getBasePrice(sym);
      const vol = getVolatility(sym);
      const history = generateHistory(basePrice, vol, 22);
      const price = history[history.length - 1];
      const prev = history[history.length - 2];
      results[sym] = {
        price: price,
        change: price - prev,
        changePct: ((price - prev) / prev) * 100,
        name: STOCK_NAMES[sym] || sym,
        history: history,
        high: price * 1.005,
        low: price * 0.995,
        volume: Math.floor(Math.random() * 50000000) + 1000000
      };
    });
  }

  STATE.marketData = results;
  document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();

  if (STATE.benchmarkStart === null && results[STATE.benchmark]) {
    STATE.benchmarkStart = results[STATE.benchmark].price;
  }
  return results;
}

function getBasePrice(sym) {
  const bases = { 'AAPL':190,'MSFT':420,'GOOGL':175,'AMZN':185,'NVDA':130,'META':500,'TSLA':250,'SPY':525,'QQQ':450,'JPM':195,'V':275,'UNH':520,'XOM':105,'JNJ':155,'WMT':170,'DIA':390,'IWM':210,'GLD':195,'TLT':92,'BTC-USD':65000 };
  return bases[sym] || 100;
}

function getVolatility(sym) {
  const vols = { 'AAPL':0.015,'MSFT':0.013,'GOOGL':0.018,'AMZN':0.017,'NVDA':0.025,'META':0.02,'TSLA':0.03,'SPY':0.008,'QQQ':0.012,'JPM':0.014,'V':0.011,'UNH':0.013,'XOM':0.016,'JNJ':0.009,'WMT':0.008,'DIA':0.007,'IWM':0.014,'GLD':0.008,'TLT':0.01,'BTC-USD':0.035 };
  return vols[sym] || 0.015;
}

function generateHistory(base, vol, days) {
  const h = [base];
  for (let i = 1; i < days; i++) {
    const drift = 0.0003; // slight upward bias
    const shock = (Math.random() - 0.5) * 2 * vol;
    h.push(Math.max(0.01, h[i-1] * (1 + drift + shock)));
  }
  return h;
}

// Load historical data from CSV or JSON
async function loadHistoricalData(symbols, startDate, endDate) {
  // This function would load historical data from a file or API
  // For now, we'll generate realistic historical data
  const data = {};

  symbols.forEach(sym => {
    const basePrice = getBasePrice(sym);
    const vol = getVolatility(sym);
    const days = 252; // ~1 year of trading days
    const history = [];

    let price = basePrice;
    const start = new Date(startDate || '2023-01-01');

    for (let i = 0; i < days; i++) {
      const date = new Date(start);
      date.setDate(date.getDate() + i);

      const drift = 0.0003;
      const shock = (Math.random() - 0.5) * 2 * vol;
      const open = price;
      const close = price * (1 + drift + shock);
      const high = Math.max(open, close) * (1 + Math.random() * 0.01);
      const low = Math.min(open, close) * (1 - Math.random() * 0.01);
      const volume = Math.floor(Math.random() * 50000000) + 1000000;

      history.push({ date: date.toISOString().split('T')[0], open, high, low, close, volume });
      price = close;
    }

    data[sym] = history;
  });

  return data;
}

// Advance to next historical day
function advanceHistoricalDay() {
  if (!STATE.useHistoricalData || !STATE.historicalData) {
    simulateNextDay(); // Fallback to simulation
    return;
  }

  STATE.historicalDayIndex++;

  Object.keys(STATE.marketData).forEach(sym => {
    const histData = STATE.historicalData[sym];
    if (!histData || STATE.historicalDayIndex >= histData.length) {
      // No more historical data, fallback to simulation
      STATE.useHistoricalData = false;
      simulateNextDay();
      return;
    }

    const todayData = histData[STATE.historicalDayIndex];
    const yesterdayData = histData[STATE.historicalDayIndex - 1];

    const d = STATE.marketData[sym];
    const newPrice = todayData.close;
    const prevPrice = yesterdayData?.close || todayData.open;
    const change = newPrice - prevPrice;

    d.change = change;
    d.changePct = (change / prevPrice) * 100;
    d.price = newPrice;
    d.history.push(newPrice);
    if (d.history.length > 252) d.history.shift();
    d.high = todayData.high;
    d.low = todayData.low;
    d.volume = todayData.volume;
  });
}

// Simulate next day price movement (original function, now only used as fallback)
function simulateNextDay() {
  Object.keys(STATE.marketData).forEach(sym => {
    const d = STATE.marketData[sym];
    const vol = getVolatility(sym);
    const drift = 0.0003;
    const shock = (Math.random() - 0.5) * 2 * vol;
    const newPrice = d.price * (1 + drift + shock);
    const change = newPrice - d.price;
    d.change = change;
    d.changePct = (change / d.price) * 100;
    d.price = newPrice;
    d.history.push(newPrice);
    if (d.history.length > 252) d.history.shift();
    d.high = Math.max(d.price, d.price * (1 + Math.random() * 0.005));
    d.low = Math.min(d.price, d.price * (1 - Math.random() * 0.005));
  });
}

// ===== RENDER MARKET DATA =====
function renderStockList() {
  const el = document.getElementById('stockList');
  el.innerHTML = '';
  Object.entries(STATE.marketData).forEach(([sym, d], i) => {
    const isUp = d.changePct >= 0;
    const held = STATE.holdings[sym] ? ` ¬∑ ${STATE.holdings[sym].shares} shares` : '';
    const card = document.createElement('div');
    card.className = 'stock-card' + (held ? ' selected' : '');
    card.innerHTML = `
      <div class="stock-row">
        <div>
          <div class="stock-sym">${sym}</div>
          <div class="stock-name">${d.name}${held}</div>
        </div>
        <div>
          <div class="stock-price">$${formatPrice(d.price)}</div>
          <div class="stock-chg ${isUp?'green':'red'}">${isUp?'+':''}${d.changePct.toFixed(2)}%</div>
        </div>
      </div>
    `;
    el.appendChild(card);
  });
}

function formatPrice(p) {
  if (p >= 10000) return p.toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0});
  return p.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
}

// ===== PORTFOLIO CALCULATIONS =====
function getPortfolioValue() {
  let total = STATE.cash;
  Object.entries(STATE.holdings).forEach(([sym, h]) => {
    const price = STATE.marketData[sym]?.price || 0;
    total += h.shares * price;
  });
  return total;
}

function updateUI() {
  const pv = getPortfolioValue();
  const startCap = STATE.startCapital;
  const totalRet = ((pv - startCap) / startCap) * 100;

  // Benchmark return
  let benchRet = 0;
  if (STATE.benchmarkStart && STATE.marketData[STATE.benchmark]) {
    benchRet = ((STATE.marketData[STATE.benchmark].price - STATE.benchmarkStart) / STATE.benchmarkStart) * 100;
  }
  const alpha = totalRet - benchRet;

  // Max drawdown
  if (pv > STATE.peakValue) STATE.peakValue = pv;
  const dd = ((STATE.peakValue - pv) / STATE.peakValue) * 100;
  if (dd > STATE.maxDrawdown) STATE.maxDrawdown = dd;

  // Daily returns for Sharpe
  if (STATE.history.length > 0) {
    const prevVal = STATE.history[STATE.history.length - 1].portfolioValue;
    STATE.dailyReturns.push((pv - prevVal) / prevVal);
  }
  const sharpe = calcSharpe(STATE.dailyReturns);

  // Win rate
  const winTrades = STATE.trades.filter(t => t.pnl > 0).length;
  const closedTrades = STATE.trades.filter(t => t.pnl !== undefined).length;
  const winRate = closedTrades > 0 ? (winTrades / closedTrades * 100) : 0;

  // Score: alpha * sharpe bonus
  STATE.score = Math.round(alpha * 10 + sharpe * 50 + (winRate > 50 ? winRate : 0));

  // Update DOM
  document.getElementById('totalValue').textContent = '$' + pv.toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0});
  document.getElementById('totalValue').className = 'value ' + (totalRet >= 0 ? 'green' : 'red');

  const dailyPL = STATE.history.length > 0 ? pv - STATE.history[STATE.history.length - 1].portfolioValue : 0;
  document.getElementById('dailyPL').textContent = (dailyPL >= 0 ? '+' : '') + '$' + dailyPL.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
  document.getElementById('dailyPL').className = 'value ' + (dailyPL >= 0 ? 'green' : 'red');

  document.getElementById('totalReturn').textContent = (totalRet >= 0 ? '+' : '') + totalRet.toFixed(2) + '%';
  document.getElementById('totalReturn').className = 'value ' + (totalRet >= 0 ? 'green' : 'red');

  document.getElementById('vsBenchmark').textContent = (alpha >= 0 ? '+' : '') + alpha.toFixed(2) + '%';
  document.getElementById('vsBenchmark').className = 'value ' + (alpha >= 0 ? 'green' : 'red');

  document.getElementById('aiScore').textContent = STATE.score;
  document.getElementById('bigScore').textContent = STATE.score;

  document.getElementById('gameDay').textContent = STATE.day;
  document.getElementById('gameCash').textContent = '$' + STATE.cash.toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0});
  document.getElementById('tradeCount').textContent = STATE.trades.length;

  document.getElementById('sharpeVal').textContent = sharpe.toFixed(2);
  document.getElementById('maxDDVal').textContent = STATE.maxDrawdown.toFixed(2) + '%';
  document.getElementById('winRateVal').textContent = winRate.toFixed(0) + '%';
  document.getElementById('benchRetVal').textContent = (benchRet >= 0 ? '+' : '') + benchRet.toFixed(2) + '%';

  // Update chart
  const benchVal = STATE.benchmarkStart ? (STATE.startCapital * (1 + benchRet / 100)) : STATE.startCapital;
  STATE.history.push({ day: STATE.day, portfolioValue: pv, benchmarkValue: benchVal });

  if (perfChart) {
    perfChart.data.labels = STATE.history.map(h => 'Day ' + h.day);
    perfChart.data.datasets[0].data = STATE.history.map(h => h.portfolioValue);
    perfChart.data.datasets[1].data = STATE.history.map(h => h.benchmarkValue);
    perfChart.update('none');
  }

  renderStockList();
  renderHoldings();
  renderAllocBar();
}

function calcSharpe(returns) {
  if (returns.length < 2) return 0;
  const mean = returns.reduce((a,b)=>a+b,0) / returns.length;
  const std = Math.sqrt(returns.reduce((a,b)=>a+(b-mean)**2,0) / returns.length);
  if (std === 0) return 0;
  return (mean / std) * Math.sqrt(252);
}

function renderHoldings() {
  const tbody = document.getElementById('holdingsBody');
  const entries = Object.entries(STATE.holdings);
  if (entries.length === 0) {
    tbody.innerHTML = '<tr><td colspan="6" style="text-align:center;color:var(--muted);padding:20px">No holdings yet ‚Äî let the AI trade!</td></tr>';
    return;
  }
  const pv = getPortfolioValue();
  tbody.innerHTML = entries.map(([sym, h]) => {
    const price = STATE.marketData[sym]?.price || 0;
    const val = h.shares * price;
    const pnl = (price - h.avgCost) * h.shares;
    const pnlPct = ((price - h.avgCost) / h.avgCost * 100);
    const weight = (val / pv * 100);
    return `<tr>
      <td><strong>${sym}</strong></td>
      <td>${h.shares}</td>
      <td>$${formatPrice(h.avgCost)}</td>
      <td>$${formatPrice(price)}</td>
      <td class="${pnl>=0?'green':'red'}">${pnl>=0?'+':''}$${pnl.toFixed(2)} (${pnlPct>=0?'+':''}${pnlPct.toFixed(1)}%)</td>
      <td>${weight.toFixed(1)}%</td>
    </tr>`;
  }).join('');
}

function renderAllocBar() {
  const bar = document.getElementById('allocBar');
  const pv = getPortfolioValue();
  const entries = Object.entries(STATE.holdings);
  if (entries.length === 0 || pv === 0) {
    bar.innerHTML = '<div class="alloc-seg" style="width:100%;background:var(--muted)">100% CASH</div>';
    return;
  }
  let html = '';
  const cashPct = (STATE.cash / pv * 100);
  entries.forEach(([sym, h], i) => {
    const val = h.shares * (STATE.marketData[sym]?.price || 0);
    const pct = val / pv * 100;
    if (pct > 2) {
      html += `<div class="alloc-seg" style="width:${pct}%;background:${COLORS[i%COLORS.length]}" title="${sym}: ${pct.toFixed(1)}%">${sym} ${pct.toFixed(0)}%</div>`;
    }
  });
  if (cashPct > 2) {
    html += `<div class="alloc-seg" style="width:${cashPct}%;background:#475569">CASH ${cashPct.toFixed(0)}%</div>`;
  }
  bar.innerHTML = html;
}

// ===== TRADING FUNCTIONS =====
function executeBuy(symbol, shares) {
  const price = STATE.marketData[symbol]?.price;
  if (!price) return { success: false, error: `No market data for ${symbol}. Available symbols: ${Object.keys(STATE.marketData).join(', ')}` };

  const cost = shares * price;
  if (cost > STATE.cash) {
    const maxShares = Math.floor(STATE.cash / price);
    return {
      success: false,
      error: `Insufficient cash. Need $${cost.toFixed(2)}, have $${STATE.cash.toFixed(2)}. You can afford ${maxShares} shares of ${symbol} at $${price.toFixed(2)}/share.`
    };
  }

  // Slippage: 5bps
  const slippage = price * 0.0005;
  const execPrice = price + slippage;
  const totalCost = shares * execPrice;

  if (STATE.holdings[symbol]) {
    const h = STATE.holdings[symbol];
    const newShares = h.shares + shares;
    h.avgCost = (h.avgCost * h.shares + execPrice * shares) / newShares;
    h.shares = newShares;
  } else {
    STATE.holdings[symbol] = { shares: shares, avgCost: execPrice };
  }
  STATE.cash -= totalCost;

  const trade = { day: STATE.day, type: 'BUY', symbol, shares, price: execPrice, total: totalCost, pnl: 0 };
  STATE.trades.push(trade);
  return { success: true, trade };
}

function executeSell(symbol, shares) {
  if (!STATE.holdings[symbol]) return { success: false, error: 'No position in ' + symbol };
  const h = STATE.holdings[symbol];
  if (shares > h.shares) return { success: false, error: `Only have ${h.shares} shares of ${symbol}` };

  const price = STATE.marketData[symbol]?.price;
  if (!price) return { success: false, error: 'No market data for ' + symbol };

  const slippage = price * 0.0005;
  const execPrice = price - slippage;
  const proceeds = shares * execPrice;
  const pnl = (execPrice - h.avgCost) * shares;

  h.shares -= shares;
  if (h.shares <= 0) delete STATE.holdings[symbol];
  STATE.cash += proceeds;

  const trade = { day: STATE.day, type: 'SELL', symbol, shares, price: execPrice, total: proceeds, pnl };
  STATE.trades.push(trade);
  return { success: true, trade, pnl };
}

function executeRebalance(targetAllocations) {
  // targetAllocations: { AAPL: 0.3, MSFT: 0.2, CASH: 0.5 }
  const pv = getPortfolioValue();
  const results = [];

  // First sell everything
  Object.keys(STATE.holdings).forEach(sym => {
    if (STATE.holdings[sym]) {
      const r = executeSell(sym, STATE.holdings[sym].shares);
      results.push(r);
    }
  });

  // Then buy according to targets
  Object.entries(targetAllocations).forEach(([sym, weight]) => {
    if (sym === 'CASH' || weight <= 0) return;
    const price = STATE.marketData[sym]?.price;
    if (!price) return;
    const targetVal = pv * weight;
    const shares = Math.floor(targetVal / price);
    if (shares > 0) {
      const r = executeBuy(sym, shares);
      results.push(r);
    }
  });

  return results;
}

// ===== AI AGENT =====
const TOOL_DEFINITIONS = [
  {
    type: "function",
    function: {
      name: "buy_stock",
      description: "Buy shares of a stock. Returns trade confirmation with execution price including slippage.",
      parameters: {
        type: "object",
        properties: {
          symbol: { type: "string", description: "Stock ticker symbol (e.g., AAPL, MSFT, SPY)" },
          shares: { type: "number", description: "Number of shares to buy" }
        },
        required: ["symbol", "shares"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "sell_stock",
      description: "Sell shares of a stock you own. Returns P&L on the trade.",
      parameters: {
        type: "object",
        properties: {
          symbol: { type: "string", description: "Stock ticker symbol" },
          shares: { type: "number", description: "Number of shares to sell" }
        },
        required: ["symbol", "shares"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "rebalance_portfolio",
      description: "Rebalance the entire portfolio to target allocations. Sells all current positions and re-buys according to target weights. Weights must sum to 1.0 or less (remainder stays as cash).",
      parameters: {
        type: "object",
        properties: {
          allocations: {
            type: "object",
            description: "Target allocations as {symbol: weight}. Example: {\"SPY\": 0.4, \"QQQ\": 0.3, \"GLD\": 0.1, \"CASH\": 0.2}. Weights should sum to 1.0.",
            additionalProperties: { type: "number" }
          }
        },
        required: ["allocations"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "get_portfolio_status",
      description: "Get current portfolio holdings, cash balance, total value, and performance metrics.",
      parameters: { type: "object", properties: {} }
    }
  },
  {
    type: "function",
    function: {
      name: "get_market_data",
      description: "Get current prices and recent performance for all tracked stocks.",
      parameters: { type: "object", properties: {} }
    }
  },
  {
    type: "function",
    function: {
      name: "analyze_market",
      description: "Get a market analysis summary including trending stocks, sector performance, and notable movers.",
      parameters: { type: "object", properties: {} }
    }
  },
  {
    type: "function",
    function: {
      name: "hold_position",
      description: "Hold current positions and do nothing this turn. Use this when you want to wait and see how the market develops before making changes. This is a valid strategic choice.",
      parameters: {
        type: "object",
        properties: {
          reason: { type: "string", description: "Brief explanation of why you're holding (e.g., 'Waiting for trend confirmation', 'Market too volatile', 'Current allocation optimal')" }
        },
        required: ["reason"]
      }
    }
  }
];

function handleToolCall(name, args) {
  switch (name) {
    case 'buy_stock':
      return executeBuy(args.symbol.toUpperCase(), Math.floor(args.shares));
    case 'sell_stock':
      return executeSell(args.symbol.toUpperCase(), Math.floor(args.shares));
    case 'rebalance_portfolio':
      return executeRebalance(args.allocations);
    case 'get_portfolio_status': {
      const pv = getPortfolioValue();
      return {
        cash: STATE.cash,
        totalValue: pv,
        totalReturn: ((pv - STATE.startCapital) / STATE.startCapital * 100).toFixed(2) + '%',
        holdings: Object.entries(STATE.holdings).map(([sym, h]) => ({
          symbol: sym,
          shares: h.shares,
          avgCost: h.avgCost.toFixed(2),
          currentPrice: (STATE.marketData[sym]?.price || 0).toFixed(2),
          pnl: ((STATE.marketData[sym]?.price || 0) - h.avgCost) * h.shares
        })),
        day: STATE.day,
        tradesExecuted: STATE.trades.length,
        maxDrawdown: STATE.maxDrawdown.toFixed(2) + '%'
      };
    }
    case 'get_market_data': {
      const data = {};
      Object.entries(STATE.marketData).forEach(([sym, d]) => {
        data[sym] = {
          price: d.price.toFixed(2),
          changePct: d.changePct.toFixed(2) + '%',
          trend: d.history.length > 5 ? (d.history[d.history.length-1] > d.history[d.history.length-6] ? 'UP' : 'DOWN') : 'N/A',
          weekReturn: d.history.length > 5 ? ((d.history[d.history.length-1] / d.history[d.history.length-6] - 1) * 100).toFixed(2) + '%' : 'N/A'
        };
      });
      return data;
    }
    case 'analyze_market': {
      const sorted = Object.entries(STATE.marketData).sort((a,b) => b[1].changePct - a[1].changePct);
      return {
        topGainers: sorted.slice(0,3).map(([s,d]) => `${s}: +${d.changePct.toFixed(2)}%`),
        topLosers: sorted.slice(-3).reverse().map(([s,d]) => `${s}: ${d.changePct.toFixed(2)}%`),
        marketSentiment: sorted.filter(([,d]) => d.changePct > 0).length > sorted.length/2 ? 'BULLISH' : 'BEARISH',
        avgMove: (sorted.reduce((a,[,d]) => a + d.changePct, 0) / sorted.length).toFixed(2) + '%',
        volatility: sorted.reduce((a,[,d]) => a + Math.abs(d.changePct), 0) / sorted.length > 1 ? 'HIGH' : 'NORMAL'
      };
    }
    case 'hold_position': {
      return {
        success: true,
        action: 'HOLD',
        reason: args.reason || 'Maintaining current positions',
        message: 'Held positions for this turn. No trades executed.'
      };
    }
    default:
      return { error: 'Unknown tool: ' + name };
  }
}

const STRATEGY_PROMPTS = {
  balanced: "You are a balanced portfolio manager. Aim for steady growth with moderate risk. Diversify across 4-6 stocks. Keep 10-20% cash buffer. Hold positions for 5-10 days minimum. Target Sharpe > 1.0. Trade only when conviction is high.",
  aggressive: "You are an aggressive growth trader focused on PROFIT, not activity. Concentrate in 2-4 high-conviction tech/growth stocks. Hold winners for weeks. Cut losers fast at -5%. Accept volatility but NEVER overtrade. Each trade must have 2:1 reward:risk minimum. Use hold_position often when no clear setup.",
  conservative: "You are a conservative portfolio manager. Capital preservation first. Allocate 40% bonds (TLT), 20% gold (GLD), 30% blue chips, 10% cash. Trade rarely - only on major opportunities. Hold positions for months. Use hold_position 90% of the time.",
  momentum: "You are a momentum trader. Buy the top 2-3 performers with strong 5+ day uptrends. Hold until trend breaks (3 days down). Cut losses immediately at -3%. Use hold_position when no clear trends. NEVER chase - wait for pullbacks. Quality over quantity - fewer, better trades."
};

async function callAI(userMessage, isAutomatic = false) {
  if (!STATE.apiKey) {
    addMessage('error', 'No API key set. Please reset and enter your OpenAI key.');
    return;
  }

  const pv = getPortfolioValue();
  const holdingsSummary = Object.entries(STATE.holdings).map(([sym, h]) => {
    const cur = STATE.marketData[sym]?.price || 0;
    const pnl = ((cur - h.avgCost) * h.shares).toFixed(2);
    return `  ${sym}: ${h.shares} shares @ $${h.avgCost.toFixed(2)} (now $${cur.toFixed(2)}, P&L: $${pnl})`;
  }).join('\n') || '  (no positions)';

  const topMovers = Object.entries(STATE.marketData)
    .sort((a,b) => Math.abs(b[1].changePct) - Math.abs(a[1].changePct))
    .slice(0, 8)
    .map(([s,d]) => `  ${s}: $${d.price.toFixed(2)} (${d.changePct >= 0 ? '+' : ''}${d.changePct.toFixed(2)}%)`)
    .join('\n');

  const systemPrompt = `You are a professional portfolio manager. Your PRIMARY GOAL is to MAXIMIZE PROFIT and beat the ${STATE.benchmark} benchmark through disciplined, strategic investing.

${STRATEGY_PROMPTS[STATE.strategy]}

CURRENT PORTFOLIO STATE (Day ${STATE.day}):
- Cash: $${STATE.cash.toLocaleString(undefined,{minimumFractionDigits:2})}
- Portfolio Value: $${pv.toLocaleString(undefined,{minimumFractionDigits:2})}
- Starting Capital: $${STATE.startCapital.toLocaleString()}
- Total Return: ${((pv - STATE.startCapital) / STATE.startCapital * 100).toFixed(2)}%
- Max Drawdown: ${STATE.maxDrawdown.toFixed(2)}%
- Trades Executed: ${STATE.trades.length}

CURRENT HOLDINGS:
${holdingsSummary}

TODAY'S MARKET MOVERS:
${topMovers}

AVAILABLE STOCKS: ${WATCHLIST.join(', ')}

üéØ PRIMARY OBJECTIVES:
1. MAKE MONEY - Every trade must have a clear profit thesis
2. MINIMIZE TRANSACTION COSTS - Each trade costs 5bps slippage (0.05%). Frequent trading DESTROYS returns.
3. HOLD WINNERS - Don't sell profitable positions unless the trend reverses
4. CUT LOSERS QUICKLY - If a position drops >5%, consider selling
5. BE PATIENT - Most of the time, doing nothing (hold_position) is the RIGHT move

‚ö†Ô∏è TRADING RULES:
- You MUST call one tool per turn: buy_stock, sell_stock, rebalance_portfolio, or hold_position
- hold_position is NOT a fallback - it's your PRIMARY tool. Use it ~70-80% of the time.
- Only trade when you have HIGH CONVICTION (strong trend, clear opportunity)
- NEVER trade just to "do something" - that's how you lose money
- Once you build positions, HOLD THEM for multiple days unless:
  ‚Ä¢ Clear trend reversal
  ‚Ä¢ Position down >5%
  ‚Ä¢ Better opportunity emerges
- Transaction costs eat profit: buying and selling the same stock repeatedly = guaranteed loss

üìä WHEN TO TRADE:
‚úÖ DO trade when:
  ‚Ä¢ Day 1: Need initial allocation (rebalance_portfolio recommended)
  ‚Ä¢ Strong uptrend confirmed (3+ days up, momentum accelerating)
  ‚Ä¢ Position hits stop loss (down >5%)
  ‚Ä¢ Portfolio too concentrated (>40% in one stock)

‚ùå DON'T trade when:
  ‚Ä¢ Market choppy or unclear
  ‚Ä¢ Already have good positions
  ‚Ä¢ Small daily moves (<1%)
  ‚Ä¢ Just bought/sold recently (hold at least 3-5 days)

üö® ERROR HANDLING:
- If buy fails (insufficient cash): use hold_position, don't force trades
- If sell fails (no position): use hold_position
- NEVER chase trades or retry failed actions

üí° REMEMBER: The best traders do NOTHING most of the time. Patience beats activity.`;

  const messages = [
    { role: 'system', content: systemPrompt },
    ...STATE.messages.slice(-20),
    { role: 'user', content: userMessage }
  ];

  STATE.messages.push({ role: 'user', content: userMessage });
  if (!isAutomatic) addMessage('user', userMessage);

  const thinkingEl = showThinking();

  try {
    let currentMessages = [...messages];
    let maxIterations = 3; // Allow up to 3 rounds of tool calls (prevents infinite loops)
    let iteration = 0;
    let finalReply = '';
    let hadSuccessfulTool = false;

    while (iteration < maxIterations) {
      iteration++;

      // Determine tool_choice:
      // - First iteration OR no successful tool yet: REQUIRE a tool (must make decision)
      // - After successful tool: allow 'auto' (can do more actions or finish)
      const toolChoice = (!hadSuccessfulTool || iteration === 1) ? 'required' : 'auto';

      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + STATE.apiKey
        },
        body: JSON.stringify({
          model: STATE.model,
          messages: currentMessages,
          tools: TOOL_DEFINITIONS,
          tool_choice: toolChoice,
          temperature: 0.7,
          max_tokens: 1500
        })
      });

      if (!response.ok) {
        const err = await response.json().catch(() => ({}));
        throw new Error(err.error?.message || `API Error ${response.status}`);
      }

      const data = await response.json();

      // Validate response structure
      if (!data.choices || !data.choices[0] || !data.choices[0].message) {
        throw new Error('Invalid API response structure: ' + JSON.stringify(data));
      }

      const choice = data.choices[0];

      // If the AI made tool calls, process them and loop
      if (choice.message.tool_calls && choice.message.tool_calls.length > 0) {
        const toolResults = [];
        for (const tc of choice.message.tool_calls) {
          let args;
          try { args = JSON.parse(tc.function.arguments); } catch(e) { args = {}; }
          const result = handleToolCall(tc.function.name, args);
          toolResults.push({ id: tc.id, name: tc.function.name, args, result });
          addMessage('tool', `üîß ${tc.function.name}(${JSON.stringify(args)})\n‚Üí ${JSON.stringify(result, null, 2)}`);

          // Track if any tool succeeded
          if (result && result.success !== false) {
            hadSuccessfulTool = true;
          }

          updateUI();
        }

        // Add the assistant's tool_calls message and all tool results to the conversation
        currentMessages.push(choice.message);
        for (const tr of toolResults) {
          currentMessages.push({
            role: 'tool',
            tool_call_id: tr.id,
            content: JSON.stringify(tr.result)
          });
        }

        // If there's also text content, show it
        if (choice.message.content) {
          addMessage('assistant', choice.message.content);
          finalReply = choice.message.content;
        }

        // Continue the loop so the AI can make more tool calls if needed
        continue;
      }

      // No tool calls ‚Äî this is the final text response
      if (choice.message.content) {
        finalReply = choice.message.content;
        STATE.messages.push({ role: 'assistant', content: finalReply });
        addMessage('assistant', finalReply);
      }
      break; // Done ‚Äî no more tool calls
    }

    // Safety check: If we never successfully executed a tool, force a hold_position
    if (!hadSuccessfulTool) {
      console.warn('AI failed to execute any successful tool. Forcing hold_position as fallback.');
      const holdResult = handleToolCall('hold_position', { reason: 'Unable to execute any trades this turn due to constraints' });
      addMessage('tool', `üîß hold_position({"reason":"Unable to execute any trades this turn due to constraints"})\n‚Üí ${JSON.stringify(holdResult, null, 2)}`);
      hadSuccessfulTool = true;
    }

    removeThinking(thinkingEl);
    updateUI();
    showToast(hadSuccessfulTool ? 'AI decision executed ‚úÖ' : 'AI turn complete', 'success');

  } catch (e) {
    removeThinking(thinkingEl);
    addMessage('error', '‚ùå ' + e.message);
    showToast('AI Error: ' + e.message, 'error');
  }
}

// ===== CHAT UI =====
function addMessage(type, content) {
  const container = document.getElementById('aiMessages');
  const div = document.createElement('div');
  div.className = `ai-msg ${type}`;
  const labels = { system: 'üñ•Ô∏è System', user: 'üë§ You', assistant: 'ü§ñ AI Agent', tool: 'üîß Tool Call', error: '‚ùå Error' };
  div.innerHTML = `<div class="msg-label">${labels[type] || type}</div>${formatMessage(content)}`;
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;
}

function formatMessage(msg) {
  // Simple markdown-like formatting
  return msg
    .replace(/```([\s\S]*?)```/g, '<pre>$1</pre>')
    .replace(/`([^`]+)`/g, '<code style="background:rgba(0,0,0,.3);padding:1px 4px;border-radius:3px">$1</code>')
    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
    .replace(/\n/g, '<br>');
}

function showThinking() {
  const container = document.getElementById('aiMessages');
  const div = document.createElement('div');
  div.className = 'thinking';
  div.id = 'thinkingIndicator';
  div.innerHTML = '<div class="thinking-dot"></div><div class="thinking-dot"></div><div class="thinking-dot"></div>';
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;
  return div;
}

function removeThinking(el) {
  if (el && el.parentNode) el.parentNode.removeChild(el);
}

function sendChat() {
  const input = document.getElementById('chatInput');
  const msg = input.value.trim();
  if (!msg) return;
  input.value = '';
  callAI(msg);
}

// ===== GAME ACTIONS =====
async function nextDay() {
  STATE.day++;

  // Use historical data if available, otherwise simulate
  if (STATE.useHistoricalData) {
    advanceHistoricalDay();
  } else {
    simulateNextDay();
  }

  updateUI();

  // Auto AI decision on each new day
  const pv = getPortfolioValue();
  const benchPct = STATE.benchmarkHistory.length > 1
    ? ((STATE.benchmarkHistory[STATE.benchmarkHistory.length-1] / STATE.benchmarkHistory[0] - 1) * 100).toFixed(2)
    : '0.00';
  const myPct = ((pv - STATE.startCapital) / STATE.startCapital * 100).toFixed(2);

  const marketSummary = Object.entries(STATE.marketData)
    .sort((a,b) => Math.abs(b[1].changePct) - Math.abs(a[1].changePct))
    .slice(0, 5)
    .map(([s,d]) => `${s}: ${d.changePct >= 0 ? '+' : ''}${d.changePct.toFixed(2)}%`)
    .join(', ');

  const noPositionsWarning = Object.keys(STATE.holdings).length === 0 && STATE.day === 1
    ? 'You have no positions. Consider initial allocation via rebalance_portfolio.'
    : Object.keys(STATE.holdings).length === 0
    ? 'WARNING: Still no positions. If market looks good, enter positions. Otherwise use hold_position.'
    : 'Review holdings. Only trade if you have HIGH CONVICTION. Default to hold_position.';

  await callAI(
    `Day ${STATE.day} market update. Notable moves: ${marketSummary}. Portfolio: $${pv.toLocaleString(undefined,{minimumFractionDigits:2})} (${myPct}%). Benchmark: ${benchPct}%. Cash: $${STATE.cash.toLocaleString(undefined,{minimumFractionDigits:2})}. ${noPositionsWarning}`,
    true
  );
}

async function letAIDecide() {
  document.getElementById('btnNextDay').disabled = true;
  document.getElementById('btnAutoPlay').disabled = true;
  await callAI(`Analyze current market conditions and portfolio. Determine if any high-conviction trades are warranted. Remember: most of the time, hold_position is the correct move. Only trade if you see clear opportunity. Transaction costs matter - overtrading destroys returns.`);
  document.getElementById('btnNextDay').disabled = false;
  document.getElementById('btnAutoPlay').disabled = false;
}

function manualAction(action) {
  const prompts = {
    buy: 'Analyze current market conditions and identify high-conviction buying opportunities. Only execute buy_stock if you see clear value. Otherwise use hold_position.',
    sell: 'Review holdings and determine if any positions should be sold (down >5%, trend reversal, better opportunity). Only sell if conviction is high, otherwise use hold_position.',
    rebalance: 'Analyze current portfolio allocation. If significantly out of balance or concentrated, rebalance via rebalance_portfolio. If allocation is reasonable, use hold_position.',
    hedge: 'Assess portfolio risk. If market looks risky or portfolio too aggressive, add defensive assets (GLD, TLT) or reduce exposure. If risk is acceptable, use hold_position.'
  };
  callAI(prompts[action]);
}

let autoPlayInterval = null;
let autoPlayRunning = false;

function toggleAutoPlay() {
  const btn = document.getElementById('btnAutoPlay');
  if (autoPlayInterval || autoPlayRunning) {
    clearInterval(autoPlayInterval);
    autoPlayInterval = null;
    autoPlayRunning = false;
    btn.textContent = '‚è© Auto-Play';
    btn.className = 'btn btn-primary btn-sm';
    showToast('Auto-play stopped', 'warn');
  } else {
    btn.textContent = '‚è∏Ô∏è Pause';
    btn.className = 'btn btn-danger btn-sm';
    showToast('Auto-play started! AI will trade every round.', 'success');
    autoPlayRunning = true;

    // Use a recursive async loop instead of setInterval to avoid overlapping calls
    async function autoPlayLoop() {
      if (!autoPlayRunning) return;
      try {
        document.getElementById('btnNextDay').disabled = true;
        await nextDay();
        document.getElementById('btnNextDay').disabled = false;
      } catch (e) {
        console.error('Auto-play error:', e);
        addMessage('error', '‚ùå Auto-play error: ' + e.message);
      }
      if (autoPlayRunning) {
        autoPlayInterval = setTimeout(autoPlayLoop, 4000); // 4 second gap between rounds
      }
    }
    autoPlayLoop();
  }
}

function showTradeHistory() {
  if (STATE.trades.length === 0) {
    showToast('No trades yet!', 'warn');
    return;
  }
  const summary = STATE.trades.map(t =>
    `Day ${t.day}: ${t.type} ${t.shares} ${t.symbol} @ $${formatPrice(t.price)} ($${t.total.toFixed(2)})${t.pnl ? ' P&L: $' + t.pnl.toFixed(2) : ''}`
  ).join('\n');
  addMessage('system', `üìã **Trade History (${STATE.trades.length} trades):**\n\`\`\`\n${summary}\n\`\`\``);
}

function resetGame() {
  if (autoPlayInterval) { clearInterval(autoPlayInterval); autoPlayInterval = null; }
  document.getElementById('gameUI').style.display = 'none';
  document.getElementById('setupModal').style.display = 'flex';
  STATE.cash = STATE.startCapital;
  STATE.holdings = {};
  STATE.day = 0;
  STATE.history = [];
  STATE.trades = [];
  STATE.messages = [];
  STATE.dailyReturns = [];
  STATE.peakValue = STATE.startCapital;
  STATE.maxDrawdown = 0;
  STATE.benchmarkStart = null;
  STATE.score = 0;
  document.getElementById('aiMessages').innerHTML = '';
}

// ===== STRATEGY SELECTION =====
function selectStrategy(el) {
  document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('active'));
  el.classList.add('active');
  STATE.strategy = el.dataset.strategy;
}

// ===== TOAST =====
function showToast(msg, type = '') {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.className = 'toast show ' + type;
  setTimeout(() => t.className = 'toast', 3000);
}

// ===== GAME INITIALIZATION =====
async function startGame() {
  const key = document.getElementById('apiKeyInput').value.trim();
  if (!key) {
    showToast('Please enter your OpenAI API key!', 'error');
    return;
  }

  STATE.apiKey = key;
  STATE.model = document.getElementById('modelSelect').value;
  STATE.benchmark = document.getElementById('benchmarkSelect').value;
  STATE.startCapital = parseInt(document.getElementById('startCapital').value) || 100000;
  STATE.cash = STATE.startCapital;
  STATE.peakValue = STATE.startCapital;

  document.getElementById('gameModel').textContent = STATE.model;
  document.getElementById('gameStrategy').textContent = STATE.strategy.charAt(0).toUpperCase() + STATE.strategy.slice(1);

  // Hide modal, show game
  document.getElementById('setupModal').style.display = 'none';
  document.getElementById('gameUI').style.display = 'block';

  // Initialize chart
  initCharts();

  // Check if using historical data
  const useHistorical = document.getElementById('useHistoricalData').checked;
  STATE.useHistoricalData = useHistorical;

  // Fetch or load market data
  if (useHistorical) {
    addMessage('system', 'üìö Loading historical market data for backtest...');
    STATE.historicalData = await loadHistoricalData(WATCHLIST, '2023-01-01', null);
    STATE.historicalDayIndex = 0;

    // Initialize market data from first historical day
    Object.keys(STATE.historicalData).forEach(sym => {
      const firstDay = STATE.historicalData[sym][0];
      STATE.marketData[sym] = {
        price: firstDay.close,
        change: 0,
        changePct: 0,
        name: STOCK_NAMES[sym] || sym,
        history: [firstDay.close],
        high: firstDay.high,
        low: firstDay.low,
        volume: firstDay.volume
      };
    });

    addMessage('system', `‚úÖ Historical data loaded! ${STATE.historicalData[WATCHLIST[0]].length} trading days available.`);
  } else {
    addMessage('system', 'üì° Fetching live market data...');
    await fetchMarketData();
    addMessage('system', `‚úÖ Market data loaded! Tracking ${Object.keys(STATE.marketData).length} assets.`);
  }

  renderStockList();

  addMessage('system', `${useHistorical ? 'üï∞Ô∏è BACKTEST MODE' : 'üìà LIVE MODE'} ‚Ä¢ Benchmark: ${STATE.benchmark}`);
  addMessage('system', `üí∞ Starting capital: $${STATE.startCapital.toLocaleString()}. Strategy: **${STATE.strategy}**. Let's beat the market! üöÄ`);

  // Initial portfolio snapshot
  updateUI();

  // AI introduction
  await callAI(`I just started with $${STATE.startCapital.toLocaleString()} in cash. Benchmark: ${STATE.benchmark}. Your goal is PROFIT, not activity. Each trade costs 5bps slippage - overtrading kills returns. Analyze the market and either: (A) Create initial portfolio via rebalance_portfolio if you see clear opportunities, OR (B) Use hold_position if market is unclear. Quality over quantity.`, true);
}

// ===== AUTO-REFRESH MARKET DATA =====
setInterval(async () => {
  if (document.getElementById('gameUI').style.display !== 'none') {
    // Soft refresh - just update prices slightly
    if (STATE.day > 0 && !autoPlayInterval) {
      // Small intraday moves
      Object.keys(STATE.marketData).forEach(sym => {
        const d = STATE.marketData[sym];
        const microMove = (Math.random() - 0.5) * 0.002;
        d.price *= (1 + microMove);
        d.changePct += microMove * 100;
        d.change = d.price * d.changePct / 100;
      });
      renderStockList();
    }
  }
}, 10000); // micro-updates every 10 seconds

</script>
</body>
</html>
